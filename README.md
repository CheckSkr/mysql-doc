

# 1.基础知识

### 每个程序员该知道一些计算机的时间数据
    L1 cache ............................ 0.5 ns
    Branch mispredict(转移、分支预测) ....... 5 ns
    L2 cache  ............................. 7 ns
    Mutex lock/unlock(互斥锁\解锁)........... 25 ns
    Main memory(内存)  ..................... 100 ns
    1k字节压缩(Zippy)  ...................... 3,000 ns = 3 µs
    在1Gbps的网络上发送2k字节 ................. 20,000 ns = 20 µs
    SSD随机读 ............................... 150,000 ns = 150 µs
    从内存顺序读取1MB ........................ 250,000 ns = 250 µs
    同一个数据中心往返一次 ..................... 500,000 ns = 0.5 ms
    从SSD顺序读取1MB ......................... 1,000,000 ns = 1 ms
    磁盘检索 ................................. 10,000,000 ns = 10 ms
    从磁盘里面读出1MB ........................ 20,000,000 ns = 20 ms
 

***没感觉?上面的时间扩大10亿倍的直观感受：***

### Minute:
    L1 cache: 0.5 秒(一次心跳)
    Branch mispredict 5秒
    L2 cache： 7 秒
    Mutex lock/unlock: 25秒(做一杯咖啡的时间)
### Hour:
    Main memory reference: 100秒(刷个牙齿的时间)
    1k字节压缩(Zippy):  50 分钟（一集电视剧[含广告时间]）
### Day:
    在1Gbps的网络上发送2k字节: 5.5 小时(下午上班的时间)
    
### Week
    SSD随机读： 1.7 天 (一个周末)
    从内存顺序读取1MB： 2.9 天 (一个小长假)
    同一个数据中心往返一次： 5.8 天 (近一个国庆假期)
    从SSD顺序读取1MB： 11.6 天(近两周)
   
### Year
    磁盘检索 16.5 周 (大学的一学期)
    从磁盘里面读出1MB： 7.8 个月(差不多生个娃的时间)   
    
    
 
## 基础数据结构
> B+树的演变

++二叉树++ --> ++二叉查找树++ --> ++平衡二叉树++ --> ++B树++ --> ++B+树++


**二叉树**

1.每个节点最多只能有两个叶子节点

**二叉查找树**

1. 每个节点最多只能有两个叶子节点
2. 左子树的键值总是小于根的键值，右子树的键值总是大于根的键值


**平衡二叉树**
1.符合二叉查找树的定义
2.满足任何的左右子树的高度差为1

**B树**
性质：是一种多路搜索树（并不是二叉的）：

    1.定义任意非叶子结点最多只有M个儿子；且M>2；
    2.根结点的儿子数为[2, M]；
    3.除根结点以外的非叶子结点的儿子数为[M/2, M]；
    4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
    5.非叶子结点的关键字个数=指向儿子的指针个数-1；
    6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
    7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
    8.所有叶子结点位于同一层；
    
    ![image](http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/4.JPG)
    

搜索过程：从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；

    1.关键字集合分布在整颗树中；
    2.任何一个关键字出现且只出现在一个结点中；
    3.搜索有可能在非叶子结点结束；
    4.其搜索性能等价于在关键字全集内做一次二分查找；
    5.自动层次控制；
    6.由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为lgN；
    7.B-树的性能总是等价于二分查找（与M值无关），没有B树平衡的问题；
    8.由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；



**B+树**
（算法演示：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html）
。。。。。



# 2.MySQL索引(InnoDB)

- MySQL索引本质上就是一种数据结构，目标是高效的获取数据。作用类似一本书或字典的索引。主要是以空间换取时间，以牺牲写性能换取高效读的性能。
- 索引是在mysql的存储引擎实现的，不是mysql server成名
- 一次查询可能使用到多个索引(merge index,老版的mysql查询基本就是走一个索引)



mysql 架构



一条sql执行的过程



索引的分类
   数据结构角度
   逻辑角度
   物理存储结构角度
   
索引的区分度
前缀索引
覆盖索引(三星索引)

回表
最左匹配规则

排序（索引顺序和fileSort）


临时表

index merge


Index Condition Pushdown(ICP,索引条件下推)

> ICP（index condition pushdown）是mysql利用索引（二级索引）元组和筛字段在索引中的where条件从表中提取数据记录的一种优化操作。

> ICP的思想是：存储引擎在访问索引的时候检查筛选字段在索引中的where条件（pushed index condition，推送的索引条件），如果索引元组中的数据不满足推送的索引条件，那么就过滤掉该条数据记录。ICP（优化器）尽可能的把index condition的处理从server层下推到storage engine层。storage engine使用索引过过滤不相关的数据，仅返回符合index condition条件的数据给server层。也是说数据过滤尽可能在storage engine层进行，而不是返回所有数据给server层，然后后再根据where条件进行过滤。使用ICP（mysql 5.6版本以前）和没有使用ICP的数据访问和提取过程如下：

优化器没有使用ICP时，数据访问和提取的过程如下：
    
    1. 当storage engine读取下一行时，首先读取索引元组（index tuple），然后使用索引元组在基表中（base table）定位和读取整行数据。
    2. sever层评估where条件，如果该行数据满足where条件则使用，否则丢弃。
    3. 执行1），直到最后一行数据。
    
    ![image](http://mdba.cn/wp-content/uploads/2014/01/index-access-2phases.png)
    
    






 


   







**reference:**
1. https://dzone.com/articles/every-programmer-should-know
2. https://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf
3. http://mdba.cn/2014/01/21/index-condition-pushdownicp%E7%B4%A2%E5%BC%95%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%8E%A8/






